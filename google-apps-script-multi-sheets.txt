// Google Apps Script ƒë·ªÉ qu·∫£n l√Ω multiple sheets (m·ªói b·∫£ng = 1 sheet)
// H∆∞·ªõng d·∫´n setup:
// 1. T·∫°o Google Sheet m·ªõi (ho·∫∑c d√πng sheet c√≥ s·∫µn)
// 2. T·∫°o c√°c sheets: Products, Categories, Users, Orders, Reviews, Comments
// 3. M·ªü Tools > Script editor
// 4. Paste code n√†y v√†o
// 5. L∆∞u l·∫°i (File > Save)
// 6. Ch·∫°y function testSetup() ƒë·ªÉ t·∫°o headers cho t·∫•t c·∫£ sheets
// 7. Authorize permissions
// 8. Deploy > New deployment > Web app
// 9. Execute as: Me, Who has access: Anyone
// 10. Copy Web app URL v√† paste v√†o GOOGLE_SHEETS_WEB_APP_URL
//
// üîÑ AUTO-GENERATE ID, createdAt, updatedAt (cho ng∆∞·ªùi d√πng nh·∫≠p th·ªß c√¥ng):
// 11. Setup trigger: Edit > Current project's triggers > Add trigger
//     - Function: onEdit
//     - Event source: From spreadsheet
//     - Event type: On edit
//     - Save trigger
// 12. (T√πy ch·ªçn) N·∫øu c√≥ nhi·ªÅu rows b·ªã thi·∫øu ID/timestamp, ch·∫°y function fixAllMissingIds()
//     trong Script editor ƒë·ªÉ t·ª± ƒë·ªông fix t·∫•t c·∫£
// 13. (T√πy ch·ªçn) Protect auto-generated columns: Ch·∫°y protectAutoColumns(true) ƒë·ªÉ
//     b·∫£o v·ªá c√°c c·ªôt id, createdAt, updatedAt kh·ªèi ch·ªânh s·ª≠a th·ªß c√¥ng
//     Ch·∫°y protectAutoColumns(false) ƒë·ªÉ b·ªè b·∫£o v·ªá
// 14. Settings ·ªü ƒë·∫ßu file:
//     - AUTO_GENERATE_ENABLED: b·∫≠t/t·∫Øt t·ª± ƒë·ªông generate (m·∫∑c ƒë·ªãnh: true)
//     - PROTECT_AUTO_COLUMNS: b·∫≠t/t·∫Øt b·∫£o v·ªá c√°c c·ªôt auto-generated (m·∫∑c ƒë·ªãnh: false)

// ===== CONFIGURATION =====
const SHEETS = {
  PRODUCTS: 'Products',
  CATEGORIES: 'Categories',
  USERS: 'Users',
  ORDERS: 'Orders',
  REVIEWS: 'Reviews',
  COMMENTS: 'Comments'
};

// ===== SETTINGS =====
// Auto-generate IDs, createdAt, updatedAt when users manually edit sheets
const AUTO_GENERATE_ENABLED = true; // Set to false to disable auto-generation

// Protect important columns from manual editing
// Set to true to prevent users from manually editing id, createdAt, updatedAt columns
const PROTECT_AUTO_COLUMNS = false; // Set to true to protect these columns

// ===== HEADERS =====
const HEADERS = {
  PRODUCTS: ['id', 'name', 'tagline', 'price', 'originalPrice', 'discount', 'category', 'needs', 'image', 'hoverImage', 'description', 'benefits', 'ingredients', 'howToUse', 'createdAt', 'updatedAt'],
  CATEGORIES: ['id', 'name', 'description', 'createdAt', 'updatedAt'],
  USERS: ['id', 'email', 'name', 'phone', 'address', 'role', 'createdAt', 'updatedAt'],
  ORDERS: ['id', 'orderNumber', 'customerName', 'customerEmail', 'customerPhone', 'userId', 'streetAddress', 'wardName', 'districtName', 'provinceName', 'status', 'paymentMethod', 'items', 'total', 'notes', 'createdAt', 'updatedAt'],
  REVIEWS: ['id', 'productId', 'reviewerName', 'rating', 'review', 'createdAt', 'updatedAt'],
  COMMENTS: ['id', 'productId', 'userId', 'userName', 'userEmail', 'content', 'rating', 'status', 'createdAt', 'updatedAt']
};

// ===== HELPER FUNCTIONS =====
function getOrCreateSheet(sheetName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(sheetName);

  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
    // Set headers
    const headers = HEADERS[sheetName.toUpperCase()];
    if (headers) {
      sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
      // Format header
      const headerRange = sheet.getRange(1, 1, 1, headers.length);
      headerRange.setFontWeight('bold');
      headerRange.setBackground('#4285f4');
      headerRange.setFontColor('#ffffff');
    }
  }

  return sheet;
}

function findRowByColumn(sheet, columnIndex, searchValue) {
  const data = sheet.getDataRange().getValues();
  // Normalize search value to string for flexible comparison
  const normalizedSearch = String(searchValue || '').trim();
  for (let i = 1; i < data.length; i++) { // Skip header
    const cellValue = data[i][columnIndex];
    // Compare both as strings for flexible matching (handles number vs string)
    if (String(cellValue || '').trim() === normalizedSearch) {
      return i + 1; // Return 1-based row number
    }
  }
  return -1;
}

// Generate a simple unique ID (similar to cuid format)
// Format: c + timestamp + random string
function generateId() {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substring(2, 15);
  const counter = Math.floor(Math.random() * 10000).toString(36);
  return 'c' + timestamp + random + counter;
}

// Get current Unix timestamp (seconds)
function getCurrentTimestamp() {
  return Math.floor(Date.now() / 1000);
}

// Validate if ID exists and is not empty
function isValidId(id) {
  return id && String(id).trim() !== '';
}

// Validate if timestamp exists and is valid number
function isValidTimestamp(timestamp) {
  return timestamp !== null && timestamp !== undefined && timestamp !== '' && !isNaN(Number(timestamp));
}

// ===== MAIN HANDLER =====
function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    const { action, table, record, records } = data;

    if (!action || !table) {
      throw new Error('Missing required fields: action, table');
    }

    const sheet = getOrCreateSheet(table);
    const tableUpper = table.toUpperCase();

    switch (action) {
      case 'create':
        return handleCreate(sheet, tableUpper, record);
      case 'update':
        return handleUpdate(sheet, tableUpper, record);
      case 'upsert':
        return handleUpsert(sheet, tableUpper, record);
      case 'bulk':
        return handleBulk(sheet, tableUpper, records);
      case 'read':
        return handleRead(sheet, tableUpper);
      default:
        throw new Error(`Unknown action: ${action}`);
    }
  } catch (error) {
    console.error('Error:', error);
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: error.toString()
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

function handleCreate(sheet, tableName, record) {
  const headers = HEADERS[tableName];
  if (!headers) {
    throw new Error(`Unknown table: ${tableName}`);
  }

  const idColumnIndex = headers.indexOf('id');

  // Auto-generate ID if missing or invalid
  if (idColumnIndex !== -1) {
    if (!isValidId(record.id)) {
      record.id = generateId();
    }
  }

  const row = headers.map(header => {
    const value = record[header];
    if (value === null || value === undefined) {
      return '';
    }
    if (typeof value === 'object') {
      return JSON.stringify(value);
    }
    return value;
  });

  sheet.appendRow(row);

  return ContentService.createTextOutput(JSON.stringify({
    success: true,
    message: 'Record created',
    row: sheet.getLastRow(),
    generatedId: idColumnIndex !== -1 ? record.id : null
  })).setMimeType(ContentService.MimeType.JSON);
}

function handleUpdate(sheet, tableName, record) {
  const headers = HEADERS[tableName];
  if (!headers) {
    throw new Error(`Unknown table: ${tableName}`);
  }

  const idColumnIndex = headers.indexOf('id');
  if (idColumnIndex === -1) {
    throw new Error('ID column not found');
  }

  const rowNumber = findRowByColumn(sheet, idColumnIndex, record.id);
  if (rowNumber === -1) {
    throw new Error(`Record not found: ${record.id}`);
  }

  const row = headers.map(header => {
    const value = record[header];
    if (value === null || value === undefined) {
      return '';
    }
    if (typeof value === 'object') {
      return JSON.stringify(value);
    }
    return value;
  });

  sheet.getRange(rowNumber, 1, 1, row.length).setValues([row]);

  return ContentService.createTextOutput(JSON.stringify({
    success: true,
    message: 'Record updated',
    row: rowNumber
  })).setMimeType(ContentService.MimeType.JSON);
}

function handleUpsert(sheet, tableName, record) {
  const headers = HEADERS[tableName];
  if (!headers) {
    throw new Error(`Unknown table: ${tableName}`);
  }

  const idColumnIndex = headers.indexOf('id');
  if (idColumnIndex === -1) {
    throw new Error('ID column not found');
  }

  const rowNumber = findRowByColumn(sheet, idColumnIndex, record.id);

  if (rowNumber === -1) {
    return handleCreate(sheet, tableName, record);
  } else {
    return handleUpdate(sheet, tableName, record);
  }
}

function handleBulk(sheet, tableName, records) {
  const headers = HEADERS[tableName];
  if (!headers) {
    throw new Error(`Unknown table: ${tableName}`);
  }

  const idColumnIndex = headers.indexOf('id');

  const rows = records.map(record => {
    // Auto-generate ID if missing or invalid
    if (idColumnIndex !== -1 && !isValidId(record.id)) {
      record.id = generateId();
    }

    return headers.map(header => {
      const value = record[header];
      if (value === null || value === undefined) {
        return '';
      }
      if (typeof value === 'object') {
        return JSON.stringify(value);
      }
      return value;
    });
  });

  if (rows.length > 0) {
    const startRow = sheet.getLastRow() + 1;
    sheet.getRange(startRow, 1, rows.length, headers.length).setValues(rows);
  }

  return ContentService.createTextOutput(JSON.stringify({
    success: true,
    message: `${rows.length} records created`,
    startRow: sheet.getLastRow() + 1 - rows.length
  })).setMimeType(ContentService.MimeType.JSON);
}

function handleRead(sheet, tableName) {
  const headers = HEADERS[tableName];
  if (!headers) {
    throw new Error(`Unknown table: ${tableName}`);
  }

  const data = sheet.getDataRange().getValues();
  const records = [];
  const idColumnIndex = headers.indexOf('id');
  const needsFix = [];

  for (let i = 1; i < data.length; i++) { // Skip header
    const record = {};
    headers.forEach((header, index) => {
      let value = data[i][index];
      if (value === '' || value === null) {
        record[header] = null;
      } else {
        // Try to parse JSON strings
        if (typeof value === 'string' && (value.startsWith('[') || value.startsWith('{'))) {
          try {
            value = JSON.parse(value);
          } catch (e) {
            // Not JSON, keep as string
          }
        }
        record[header] = value;
      }
    });

    // Auto-generate ID if missing or invalid when reading
    if (idColumnIndex !== -1 && !isValidId(record.id)) {
      record.id = generateId();
      needsFix.push({ row: i + 1, id: record.id });
      // Update the ID in the sheet
      sheet.getRange(i + 1, idColumnIndex + 1).setValue(record.id);
    }

    records.push(record);
  }

  const response = {
    success: true,
    records: records
  };

  if (needsFix.length > 0) {
    response.warning = `${needsFix.length} records had invalid/missing IDs and were auto-generated`;
    response.fixedIds = needsFix;
  }

  return ContentService.createTextOutput(JSON.stringify(response)).setMimeType(ContentService.MimeType.JSON);
}

// ===== TEST FUNCTIONS =====
function testSetup() {
  // Create all sheets with headers
  Object.values(SHEETS).forEach(sheetName => {
    const sheet = getOrCreateSheet(sheetName);
    const tableUpper = sheetName.toUpperCase();
    const headers = HEADERS[tableUpper];

    if (headers) {
      // Check if header row exists and is correct
      const existingHeaders = sheet.getRange(1, 1, 1, headers.length).getValues()[0];
      const headersMatch = existingHeaders.length === headers.length &&
                          existingHeaders.every((h, i) => h === headers[i]);

      // If no header or header doesn't match, set it
      if (!headersMatch || sheet.getLastRow() === 0) {
        sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
        // Format header
        const headerRange = sheet.getRange(1, 1, 1, headers.length);
        headerRange.setFontWeight('bold');
        headerRange.setBackground('#4285f4');
        headerRange.setFontColor('#ffffff');
      }
    }
  });
  Logger.log('All sheets created successfully with headers!');
}

function testCreate() {
  const testData = {
    action: 'create',
    table: 'Products',
    record: {
      id: 'test-1',
      name: 'Test Product',
      tagline: 'Test Tagline',
      price: 100000,
      category: 'Serum',
      image: '/test.jpg',
      hoverImage: '/test-hover.jpg',
      needs: '[]',
      createdAt: Math.floor(Date.now() / 1000),
      updatedAt: Math.floor(Date.now() / 1000)
    }
  };

  const mockEvent = {
    postData: {
      contents: JSON.stringify(testData)
    }
  };

  const result = doPost(mockEvent);
  Logger.log(result.getContent());
}

function testRead() {
  const testData = {
    action: 'read',
    table: 'Products'
  };

  const mockEvent = {
    postData: {
      contents: JSON.stringify(testData)
    }
  };

  const result = doPost(mockEvent);
  Logger.log(result.getContent());
}

// ===== TRIGGER FUNCTION =====
// Auto-generate IDs, createdAt, updatedAt when users manually add rows in Google Sheets
// This trigger will automatically run when users edit the sheet
// Setup: Edit > Current project's triggers > Add trigger
//   - Function: onEdit
//   - Event source: From spreadsheet
//   - Event type: On edit
function onEdit(e) {
  try {
    // Skip if auto-generation is disabled
    if (!AUTO_GENERATE_ENABLED) {
      return;
    }

    const sheet = e.source.getActiveSheet();
    const sheetName = sheet.getName();

    // Only process known sheets
    if (!Object.values(SHEETS).includes(sheetName)) {
      return;
    }

    const range = e.range;
    const startRow = range.getRow();
    const numRows = range.getNumRows();
    const startCol = range.getColumn();
    const numCols = range.getNumColumns();

    // Skip header row
    if (startRow === 1) {
      return;
    }

    const tableUpper = sheetName.toUpperCase();
    const headers = HEADERS[tableUpper];
    if (!headers) {
      return;
    }

    const idColumnIndex = headers.indexOf('id');
    const createdAtColumnIndex = headers.indexOf('createdAt');
    const updatedAtColumnIndex = headers.indexOf('updatedAt');

    if (idColumnIndex === -1) {
      return;
    }

    const currentTimestamp = getCurrentTimestamp();
    let hasChanges = false;

    // Process all edited rows (handles paste operations with multiple rows)
    for (let i = 0; i < numRows; i++) {
      const currentRow = startRow + i;

      // Skip if row is empty or doesn't have enough columns
      if (currentRow > sheet.getLastRow()) {
        continue;
      }

      // Check if user is editing protected columns
      if (PROTECT_AUTO_COLUMNS) {
        const editedColumns = [];
        for (let j = 0; j < numCols; j++) {
          const colIndex = startCol + j - 1; // Convert to 0-based index
          if (colIndex === idColumnIndex ||
              colIndex === createdAtColumnIndex ||
              colIndex === updatedAtColumnIndex) {
            editedColumns.push(headers[colIndex]);
          }
        }

        if (editedColumns.length > 0) {
          // Clear the protected cell and restore original value
          range.getSheet().getActiveRange().clearContent();
          SpreadsheetApp.getActiveSpreadsheet().toast(
            `Columns ${editedColumns.join(', ')} are protected and auto-generated.`,
            'Protected Column',
            3
          );
          continue;
        }
      }

      const idCell = sheet.getRange(currentRow, idColumnIndex + 1);
      const currentId = idCell.getValue();

      // Auto-generate ID if missing or invalid
      if (!isValidId(currentId)) {
        const newId = generateId();
        idCell.setValue(newId);
        hasChanges = true;
      }

      // Auto-generate createdAt if missing or invalid (only for new rows)
      if (createdAtColumnIndex !== -1) {
        const createdAtCell = sheet.getRange(currentRow, createdAtColumnIndex + 1);
        const createdAtValue = createdAtCell.getValue();

        // If createdAt is empty, set current timestamp (new record)
        if (!isValidTimestamp(createdAtValue)) {
          createdAtCell.setValue(currentTimestamp);
          hasChanges = true;
        }
      }

      // Auto-update updatedAt whenever row is edited (always update)
      if (updatedAtColumnIndex !== -1) {
        const updatedAtCell = sheet.getRange(currentRow, updatedAtColumnIndex + 1);
        updatedAtCell.setValue(currentTimestamp);
        hasChanges = true;
      }
    }

    // Show notification if changes were made
    if (hasChanges && numRows <= 5) {
      SpreadsheetApp.getActiveSpreadsheet().toast(
        'Auto-generated ID, createdAt, and updatedAt',
        'Auto-Generated',
        3
      );
    }
  } catch (error) {
    // Silently fail to avoid disrupting user workflow
    Logger.log('onEdit error: ' + error.toString());
  }
}

// ===== HELPER FUNCTION FOR MANUAL FIX =====
// Users can run this function manually to fix all rows with missing/invalid IDs, createdAt, updatedAt
// Usage: In Script editor, select this function and click Run
function fixAllMissingIds() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let totalFixed = { ids: 0, timestamps: 0 };
  const currentTimestamp = getCurrentTimestamp();

  Object.values(SHEETS).forEach(sheetName => {
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet) return;

    const tableUpper = sheetName.toUpperCase();
    const headers = HEADERS[tableUpper];
    if (!headers) return;

    const idColumnIndex = headers.indexOf('id');
    const createdAtColumnIndex = headers.indexOf('createdAt');
    const updatedAtColumnIndex = headers.indexOf('updatedAt');

    if (idColumnIndex === -1) return;

    const data = sheet.getDataRange().getValues();
    let fixedIds = 0;
    let fixedTimestamps = 0;

    // Check all rows except header
    for (let i = 1; i < data.length; i++) {
      const rowNum = i + 1;
      let rowChanged = false;

      // Fix ID
      const idValue = data[i][idColumnIndex];
      if (!isValidId(idValue)) {
        const newId = generateId();
        sheet.getRange(rowNum, idColumnIndex + 1).setValue(newId);
        fixedIds++;
        rowChanged = true;
      }

      // Fix createdAt (only if missing, preserve existing)
      if (createdAtColumnIndex !== -1) {
        const createdAtValue = data[i][createdAtColumnIndex];
        if (!isValidTimestamp(createdAtValue)) {
          sheet.getRange(rowNum, createdAtColumnIndex + 1).setValue(currentTimestamp);
          fixedTimestamps++;
          rowChanged = true;
        }
      }

      // Always update updatedAt
      if (updatedAtColumnIndex !== -1) {
        sheet.getRange(rowNum, updatedAtColumnIndex + 1).setValue(currentTimestamp);
        if (!rowChanged) {
          fixedTimestamps++;
        }
      }
    }

    if (fixedIds > 0 || fixedTimestamps > 0) {
      Logger.log(`Fixed ${fixedIds} IDs and ${fixedTimestamps} timestamps in ${sheetName}`);
      totalFixed.ids += fixedIds;
      totalFixed.timestamps += fixedTimestamps;
    }
  });

  const totalChanges = totalFixed.ids + totalFixed.timestamps;
  if (totalChanges > 0) {
    ss.toast(
      `Fixed ${totalFixed.ids} IDs and ${totalFixed.timestamps} timestamps across all sheets`,
      'Fix Complete',
      5
    );
  } else {
    ss.toast('All IDs and timestamps are valid!', 'No Issues', 3);
  }

  return totalFixed;
}

// ===== PROTECTION FUNCTION =====
// Protect or unprotect auto-generated columns (id, createdAt, updatedAt)
// Usage: Call protectAutoColumns(true) to protect, protectAutoColumns(false) to unprotect
function protectAutoColumns(protect) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let protectedCount = 0;

  Object.values(SHEETS).forEach(sheetName => {
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet) return;

    const tableUpper = sheetName.toUpperCase();
    const headers = HEADERS[tableUpper];
    if (!headers) return;

    const idColumnIndex = headers.indexOf('id');
    const createdAtColumnIndex = headers.indexOf('createdAt');
    const updatedAtColumnIndex = headers.indexOf('updatedAt');

    const columnsToProtect = [];
    if (idColumnIndex !== -1) columnsToProtect.push(idColumnIndex + 1);
    if (createdAtColumnIndex !== -1) columnsToProtect.push(createdAtColumnIndex + 1);
    if (updatedAtColumnIndex !== -1) columnsToProtect.push(updatedAtColumnIndex + 1);

    if (columnsToProtect.length === 0) return;

    // Get all existing protections
    const protections = sheet.getProtections(SpreadsheetApp.ProtectionType.RANGE);

    if (protect) {
      // Protect columns
      columnsToProtect.forEach(colIndex => {
        // Check if already protected
        const existing = protections.find(p => {
          const range = p.getRange();
          return range.getColumn() === colIndex && range.getNumColumns() === 1;
        });

        if (!existing) {
          const column = sheet.getRange(1, colIndex, sheet.getLastRow(), 1);
          const protection = column.protect().setDescription(`Auto-generated: ${headers[colIndex - 1]}`);

          // Allow users to edit rows (for new data entry), but warn them
          protection.setWarningOnly(true);
          protectedCount++;
        }
      });

      // Format protected columns to show they're auto-generated
      columnsToProtect.forEach(colIndex => {
        const headerRange = sheet.getRange(1, colIndex);
        headerRange.setBackground('#fff3cd'); // Light yellow warning
        headerRange.setNote('Auto-generated. Manual edits will be overridden.');
      });
    } else {
      // Remove protection
      columnsToProtect.forEach(colIndex => {
        const existing = protections.find(p => {
          const range = p.getRange();
          return range.getColumn() === colIndex && range.getNumColumns() === 1;
        });

        if (existing) {
          existing.remove();
          protectedCount++;
        }

        // Reset formatting
        const headerRange = sheet.getRange(1, colIndex);
        headerRange.setBackground('#4285f4'); // Back to blue
        headerRange.clearNote();
      });
    }
  });

  const message = protect
    ? `Protected ${protectedCount} auto-generated columns`
    : `Removed protection from ${protectedCount} columns`;

  ss.toast(message, protect ? 'Protection Enabled' : 'Protection Disabled', 5);
  Logger.log(message);

  return protectedCount;
}
